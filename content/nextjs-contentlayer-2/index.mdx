---
title: 'NextJs13 에서 contentlayer 사용하여 정적블로그 만들기(2) '
description: 'Next.Js 에서 contentlayer 사용하여 정적블로그 손쉽게 만들어보는 방법'
image: '../../public/blogs/logo/contentlayermain.png'
publishedAt: '2023-11-03'
updatedAt: '2023-11-03'
author: 'DH'
isPublished: true
tags:
  - Next.JS
---

Next.JS 프레임워크에서 contentlayer 라이브러리를 사용하여 정적블로그 만들기 2탄

## 1. 블로그 작성방법

```
---
title: 'NextJs13 에서 contentlayer 사용하여 정적블로그 만들기(1) '
description: 'Next.Js 에서 contentlayer 사용하여 정적블로그 손쉽게 만들어보는 방법 '
image: '../../public/blogs/christina-wocintechchat-com-OtHEYbQXLFU-unsplash.jpg'
publishedAt: '2023-11-03'
updatedAt: '2023-11-03'
author: 'DH'
isPublished: true
tags:
  - Next.JS
---

안녕하세요 오늘은 Next.JS 13 App Routers 알아보겠습니다.

```

이전에 작성을 하고 나서 결과물에 대한 확인을 아직 안한 상황입니다.

작성을 하고 저장을 한후, yarn dev를 실행시

Next.JS 프로젝트 폴더 목록중 보시면 가장위에 .contentlayer라는 폴더가 생성이 됩니다.

이 안에 클릭을 해보시면 .cache , generated 폴더가 있습니다. 우리가 작성된 MDX 블로그 내용물은 generated 폴더 내에 존재합니다.

이전에 contentlayer.config 파일을 작성하면서 결과물을 볼수 있는 폴더입니다.

.contentlayer/generated/index.mjs 파일을 열람해보시면 위와 같은 내용이 있습니다.

### 1.1 .contentlayer 결과물

```
// NOTE This file is auto-generated by Contentlayer

export { isType } from 'contentlayer/client'

// NOTE During development Contentlayer imports from `.mjs` files to improve HMR speeds.
// During (production) builds Contentlayer it imports from `.json` files to improve build performance.
import { allBlogs } from './Blog/_index.mjs'

export { allBlogs }

export const allDocuments = [...allBlogs]

```

.contentlayer/generated/Blog 폴더를 가보시면 \_index.mjs 파일이 있습니다.

```
// NOTE This file is auto-generated by Contentlayer

import hello__indexMdx from './hello__index.mdx.json' assert { type: 'json' }
import nextjsContentlayer_1__indexMdx from './nextjs-contentlayer-1__index.mdx.json' assert { type: 'json' }
import nextjsContentlayer_2__indexMdx from './nextjs-contentlayer-2__index.mdx.json' assert { type: 'json' }

export const allBlogs = [ hello__indexMdx, nextjsContentlayer_1__indexMdx, nextjsContentlayer_2__indexMdx ]


```

작성된 MDX 파일이 json 형태로 변경된걸 보실수 있습니다.

<Image
  src="/blogs/nextj-contentlayer-2-1.PNG"
  width="500"
  height="400"
  alt="Image"
  sizes="100vw"
/>

<Image
  src="/blogs/nextj-contentlayer-2-2.PNG"
  width="500"
  height="400"
  alt="Image"
  sizes="100vw"
/>

보시다 싶히 굉장히 많은 내용들이 있습니다. 우리가 작성했던 title , description , image , publishedAt ,

updatedAt , author , isPublished , tags 전부 포함되어져 있습니다.

현재 까지 작성된 MDX 파일이 현재는 json 형태로 변환이 되었으므로 , 이제는 json 형태로 저장된 데이터를 봐야겠죠?

## 2. 블로그 UI

제가 만든 블로그 UI 기준으로 예시로 들자면 블로그를 섹션별로 나뉘었습니다.

### 2.1 Home.tsx

```

import Image from "next/image";
import HomeCoverSection from "../components/Home/HomeCoverSection";
import { allBlogs } from "contentlayer/generated";
import FeaturedPost from "../components/Home/FeaturedPost";
import RecentPost from "../components/Home/RecentPost";
import { BlogPost } from "@/types/BlogPost";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-center ">
      <HomeCoverSection blogs={allBlogs as BlogPost[]} />
      <FeaturedPost blogs={allBlogs as BlogPost[]} />
      <RecentPost blogs={allBlogs as BlogPost[]} />
    </main>
  );
}

export interface BlogImage {
  filePath: string
  blurhashDataUrl: string
}


export interface BlogPost {
  publishedAt: string
  updatedAt: string
  image: BlogImage
  title: string
  tags: string[]
  description: string
  url: string
}

```

contentlayer/generated 파일에 allBlogs 배열로 된 json 데이터들을 각 섹션별로 props 데이터를 내려줍니다.

저는 HomeCoverSection 컴포넌트를 만들어서 가장 최신의 데이터를 블로그 메인에 보여주고 있습니다.

### HomeCoverSection.tsx

```

import { sortBlogs } from '@/src/utils'
import Image from 'next/image'
import Link from 'next/link'
import React from 'react'
import Tag from '../Element/Tag'
import { slug } from 'github-slugger'

interface BlogImage {
  filePath: string
  blurhashDataUrl: string
}

interface Blog {
  publishedAt: string
  updatedAt: string
  image: BlogImage
  title: string
  tags: string[]
  description: string
  url: string
}

const HomeCoverSection = ({ blogs }: { blogs: Blog[] }) => {
  const sortedBlogs = sortBlogs(blogs)

  const blog = sortedBlogs[0] as Blog
  return (
    <div className="inline-block w-full">
      <article className=" relative flex h-[60vh] flex-col items-start justify-end sm:mx-10 sm:h-[85vh]">
        <div className="absolute bottom-0 left-0 right-0 top-0 z-0 h-full rounded-3xl bg-gradient-to-b from-transparent from-0% to-dark" />
        <Image
          src={blog.image.filePath.replace('../public', '')}
          placeholder="blur"
          blurDataURL={blog.image.blurhashDataUrl}
          alt={blog.title}
          fill
          className="-z-10 h-full w-full rounded-3xl object-cover object-center"
        />
        <div className="z-0 flex w-full flex-col items-start justify-center p-6 text-light sm:p-8 md:p-12  lg:w-3/4 lg:p-16">
          <Tag link={`/categories/${slug(blog.tags[0])}`} name={blog.tags[0]} />
          <Link href={blog.url} className="mt-6">
            <h1 className="text-lg font-bold capitalize md:text-3xl lg:text-4xl ">
              <span
                className="bg-gradient-to-r from-accent to-accent bg-[length:0px_6px] bg-left-bottom  bg-no-repeat
                transition-[background-size] duration-500
                hover:bg-[length:100%_6px] dark:from-accentDark dark:to-accentDark "
              >
                {blog.title}
              </span>
            </h1>
          </Link>

          <p className="mt-4 hidden font-in sm:inline-block md:text-lg lg:text-xl">
            {blog.description}
          </p>
        </div>
      </article>
    </div>
  )
}

export default HomeCoverSection


```

### utils

```

import { compareDesc, parseISO } from 'date-fns'

interface Blog {
  publishedAt: string
  updatedAt: string
}

export const cx = (...className: string[]) => className.filter(Boolean).join('')

export const sortBlogs = (blogs: Blog[]) => {
  return blogs
    .slice()
    .sort((a, b) => compareDesc(parseISO(a.publishedAt), parseISO(b.updatedAt)))
}

```

utils 함수를 통해서 저는 2가지 함수를 타루고 있습니다.

우선 날짜 유틸리티 라이브러리 "date-fns" 를 사용하여 'compareEsc' 와 'parseISO' 함수를 가져옵니다.

이 함수들은 날짜 비교와 ISO 날짜 문자열 파싱에 사용합니다.

> [라이브러리 홈페이지 (date-fns)](https://date-fns.org/)

cx 함수는 클래스 이름 문자열을 인자로 받을 수 있습니다. Falsy 값을 필터링을 하므로 , 함수 내부에서 'falsy' 값('null' , 'undefined', 'false'등)

가진 클래스 이름은 모두 필터링 되어 제거됩니다. 이는 의미 있는 클래스 이름(비어 있지 않은 문자열)만 남게됩니다.

sortBlogs 함수를 통해서 블로그 게시물 배열을 정렬하도록 설계했습니다. 각 블로그 게시물에는

publishedAt , updatedAt 날짜 기준으로 비교하여, 정렬을 합니다.

```
import { sortBlogs } from '@/src/utils'
import Image from 'next/image'
import Link from 'next/link'
import React from 'react'
import Tag from '../Element/Tag'
import { slug } from 'github-slugger'

interface BlogImage {
  filePath: string
  blurhashDataUrl: string
}

interface Blog {
  publishedAt: string
  updatedAt: string
  image: BlogImage
  title: string
  tags: string[]
  description: string
  url: string
}

const HomeCoverSection = ({ blogs }: { blogs: Blog[] }) => {
  const sortedBlogs = sortBlogs(blogs)

  const blog = sortedBlogs[0] as Blog
  return (
    <div className="inline-block w-full">
      <article className=" relative flex h-[60vh] flex-col items-start justify-end sm:mx-10 sm:h-[85vh]">
        <div className="absolute bottom-0 left-0 right-0 top-0 z-0 h-full rounded-3xl bg-gradient-to-b from-transparent from-0% to-dark" />
        <Image
          src={blog.image.filePath.replace('../public', '')}
          placeholder="blur"
          blurDataURL={blog.image.blurhashDataUrl}
          alt={blog.title}
          fill
          className="-z-10 h-full w-full rounded-3xl object-cover object-center"
        />
        <div className="z-0 flex w-full flex-col items-start justify-center p-6 text-light sm:p-8 md:p-12  lg:w-3/4 lg:p-16">
          <Tag link={`/categories/${slug(blog.tags[0])}`} name={blog.tags[0]} />
          <Link href={blog.url} className="mt-6">
            <h1 className="text-lg font-bold capitalize md:text-3xl lg:text-4xl ">
              <span
                className="bg-gradient-to-r from-accent to-accent bg-[length:0px_6px] bg-left-bottom  bg-no-repeat
                transition-[background-size] duration-500
                hover:bg-[length:100%_6px] dark:from-accentDark dark:to-accentDark "
              >
                {blog.title}
              </span>
            </h1>
          </Link>

          <p className="mt-4 hidden font-in sm:inline-block md:text-lg lg:text-xl">
            {blog.description}
          </p>
        </div>
      </article>
    </div>
  )
}

export default HomeCoverSection
```

utils sortBlogs 함수를 통해서 props 로 전달받은 data blogs 를 sortBlogs 매개변수로 전달하여

sortedBlogs 날짜가 정렬된 배열의 데이터를 가지게 됩니다.

저는 거기서 sortedBlogs[0] 배열에 0번째로 가장 최신 블로그를 blog 라 변수로 했습니다.

blog 객체 데이터를 사용하여 UI 를 구성하고 있습니다. 이전에 작성한 간단 예시로 만든 블로그를 보러 가면

```
---
title: 'NextJs13 에서 contentlayer 사용하여 정적블로그 만들기(1) '
description: 'Next.Js 에서 contentlayer 사용하여 정적블로그 손쉽게 만들어보는 방법 '
image: '../../public/blogs/christina-wocintechchat-com-OtHEYbQXLFU-unsplash.jpg'
publishedAt: '2023-11-05'
updatedAt: '2023-11-05'
author: 'DH'
isPublished: true
tags:
  - Next.JS
  - web development
---

안녕하세요 오늘은 Next.JS 13 App Routers 알아보겠습니다.

```

<Image
  src="/blogs/hello blog.PNG"
  width="1180"
  height="600"
  alt="Image"
  sizes="100vw"
/>

작성된 블로그 게시물을 보실수 있습니다.

## 3.블로그를 만들면서 느낀점

솔찍히 말하면 나는 아직도 설명하는게 서툴고, 부족한점이 많은거 같다. 내가 주저리 주저리 contentlayer 를 통해

블로그를 작성하는 방법에 대해서 설명하는 글을 다시 보면, 말을 하다가 끊김이나 정보를 전달함에 있어 아쉬운 부분이 있어보인다.

하지만 이 블로그 글을 업데이를 하더라도 남겨두고 싶다. 나중에 내가 최신글을 작성하고서 발전하고있는지 없는지에 대해서

한번씩 되돌아보고 싶다는 생각이 든다. 추후에도 이전에 내가 작성한 글을 보고서, 초심을 잡고자 할때 내가 꼭 이글을 다시

되돌아 봤으면 한다.
