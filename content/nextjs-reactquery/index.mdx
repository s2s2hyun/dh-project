---
title: 'Nextjs14 + React-query '
description: 'Nextjs14 + React-query app router 적용'
image: '../../public/blogs/logo/react-query-logo.png'
publishedAt: '2024-01-17'
updatedAt: '2024-01-17'
author: 'DH'
isPublished: true
tags:
  - Next.JS
---

NextJs 와 React-query를 같이 사용한다면 어떨까?

- React-query는 NextJs 에서 pre-fetching이 가능하다. 이로 인해 성능 향상에 도움을 준다.
  📌 pre-fetching 이란? 페이지가 렌더링 되기 전에 미리 데이터를 가져오는 것을 말한다.(데이터 캐싱 작업도 pre-fetching에 포함된다.)

- 데이터 요청 코드를 쉽게 관리가 가능하다.

- 동적 데이터 관리하는 비동기 로직을 쉽게 다룰 수 있다.

## 1. 설치

[react-query tanstack Link](https://tanstack.com/query/v4/docs/react/installation)

```
# npm
npm i @tanstack/react-query
# pnpm
pnpm add @tanstack/react-query
# yarn
yarn add @tanstack/react-query
```

## 2 Next.Js 에 적용

Next.js 13.4 버전 이상은 App Router 프로젝트로 만들수있으므로, 이번 설명은 App Router 기준으로 설명을 해보겠습니다.
여러 방법이 있는데, 저는 Provider 를 만들어 거기에 client 및 쿼리 생성 함수를 작성해 Layout에 적용하는 방법을 공유하겠습니다.

### 2.1 ReactQueryProvider 만들기

```
"use client";

import { QueryClientProvider, QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";

export default function ReactQueryProviders({
  children,
}: React.PropsWithChildren) {
  const [client] = useState(
    new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false, // 윈도우가 다시 포커스되었을때 데이터를 refetch
          refetchOnMount: false, // 데이터가 stale 상태이면 컴포넌트가 마운트될 때 refetch
          retry: 1, // API 요청 실패시 재시도 하는 옵션 (설정값 만큼 재시도)
        },
      },
    })
  );

  return (
    <QueryClientProvider client={client}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

```

1. 'use client' 를 추가.
   Next.Js App router 는 기본적으로 서버 컴포넌트지만, 리액트쿼리는 QueryClientProvider 를 비롯해 서버 컴포넌트에서 작동하지 않습니다.

2. useState로 new QueryClient 생성
   참조 동일성을 유지하고 React에서 예상대로 상태를 관리하는 데 도움돼 useState로 생성. 자세한 설명은 아래 추가적으로 하겠습니다.

3. defaultOptions 설정
   서버 비용을 줄이기 위해 refetch 설정을 false 로 두었습니다.

4. 만든 queryClient를 QueryClientProvider 컴포넌트의 client에 넣어줌

5. QueryClientProvider로 래핑을 하면 모든 하위 구성 요소가 React Query 환경에 액세스 할 수 있게 됩니다. 구성 요소 계층 구조를 통해 props를 깊이 전달할 필요 없이 다양한 구성 요소 간에 전역 상태를 관리하기 위함입니다.

6. ReactQueryDevtools은 선택이며, react-query 개발 도구라고 생각하시면 됩니다.

> 추가 : queryClient 설정에 useState를 활용했을까?

useState를 활용하는 것은 React Query의 QueryClientProvider 설정에서 특별한 경우의 선택이라 할 수 있다. useState를 적용하면 참조 동일성을 유지하며, 또한 React Query와 React가 예상하는 상태 관리를 조절하고, 컴포넌트 렌더링과 상태 업데이트를 조절하기 위함이다.
이에 대한 몇 가지 이유는 다음과 같다.

1. 초기 렌더링 중 설정: React Query는 초기 렌더링 동안에 QueryClient를 설정하고 사용하기 위한 상태를 필요로 한다.
   초기 렌더링 동안에만 실행되는 함수를 제공하면 Lazy 초기 상태(Lazy inital state)를
   활용해 초기 렌더링 동안에만 QueryClient를 생성하고, 이후에는 참조 동일성을 유지한다.
   이것은 초기 설정을 효율적으로 관리하는 방법 중 하나다.
2. 동적 설정 관리: QueryClientProvider의 설정을 동적으로 변경해야 할 때, useState 를 활용해 QueryClient를 상태로 관리하는 것이 유용하다. 동적으로 설정을 변경하려면 상태를 업데이트하고 그 변경을 QueryClientProvider 에 적용하면 된다.

3. 최적화 : React Query는 렌더링 성능과 데이터 캐싱에 대한 다양한 최적화를 제공하므로, 이러한 최적화를 활용해 웹 애플리케이션의 성능을 향상시킬 수 있다.

## 3. 루트 레이아웃에 적용하기

Next.Js App Router는 라우팅에 영향을 주는 파일 및 폴더가 있는데, 그 중 하나가 layout.tsx 이다.
간단하게 얘기해서 layout.tsx는 도메인 주소에 영향을 주는 page.tsx 파일 및 그 하위 디렉토리 파일들에게 UI 및 설정을 영향을 줄 수 있는 파일이다.
이전 Next.js Page Router 구조에서 \_app.tsx 와 비슷한 기능을 가진 파일이다.

<Image
  src="/blogs/nextjs-reactquery/nextjs-approuter.png"
  width="1000"
  height="600"
  alt="Image"
  sizes="100vw"
/>

```
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import ReactQueryProviders from "@/utils/react-query-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ReactQueryProviders>{children}</ReactQueryProviders>
      </body>
    </html>
  );
}

```

구현 완료입니다.

## 4. React 앱에서 React-Query를 사용하여 데이터 가져오기 및 표시

저는 Rest Api 를 Korean json 제공된 api 를 사용하여 구현을 해보겠습니다.

[Korean json Link](https://koreanjson.com/)

```
"use client";

import React from "react";
import styles from "./page.module.css";
import { useQuery } from "@tanstack/react-query";

interface jsonDataProps {
  id: number;
  title: string;
  createdAt: string;
}

async function fetchData() {
  const response = await fetch("https://koreanjson.com/posts");
  if (!response.ok) {
    throw new Error("네트워크 응답이 안오고 있습니다.");
  }
  console.log(response, "response");
  return response.json();
}

function DataComponent() {
  const { data, isLoading, error } = useQuery({
    queryKey: ["data"],
    queryFn: fetchData,
  });

  if (isLoading) return <div>로딩중...</div>;
  if (error) return <div>오류발생: {error.message}</div>;

  return (
    <div>
      {data.map((item: jsonDataProps) => {
        return (
          <div key={item.id}>
            <div>{item.id}</div>
            <div>{item.title}</div>
            <div>{item.createdAt}</div>
          </div>
        );
      })}
    </div>
  );
}

export default function Home() {
  return (
    <main className={styles.main}>
      <div>
        <h4>Hello React-query</h4>
        <DataComponent />
      </div>
    </main>
  );
}

```

### 4.1 설명

1. fetchData 함수는 데이터를 가져오는 비동기 함수로 구성했습니다. 위에서 말했듯 koreanjson URL 에서 데이터를 가져옵니다.

2. DataComponent 함수 컴포넌트는 데이터를 가져와서 표시하는 부분이며, useQuery 훅을 사용하여 데이터를 가져오고, 데이터의 로딩 상태 및 오류 상태를 처리합니다.
   useQuery를 queryKey와 queryFn 속성을 포함한 객체를 사용합니다. <br /> 이를 통해 query 키를 ["data"]로 지정하고 query 함수를 fetchData로 지정할 수 있습니다.
   가지고온 데이터를 map 함수를 사용하여 각 데이터 항목을 순회하고, 각
   항목의 id,title,createdAt를 표기했습니다.

> [tankstack query Link](https://tanstack.com/query/latest/docs/react/guides/queries) 공식 DOCS 입니다. 아무래도 라이브러리를 사용 하다보니, 버전에 따른 사용방법이 각각 다릅니다.<br />
> 저는 전에 사용시 v3 버전을 사용했었는데, 이번에 사용한 버전은 v5 최신버전 기준으로 작성했습니다.

## 5. 마무리

이전에도 사용을 해봤지만 React-Query는 React 애플리케이션에서 데이터 가져오기, 캐싱 및 상태 관리를 처리하기 위한 강력한 라이브러리입니다.<br /> 비동기 데이터 가져오기 처리, 오류 처리, 페이지네이션, 인피니티스크롤 등 사용자에게 좋은 기능을 제공하기에 매우 좋은 라이브러리라고 생각이 듭니다.
추후에 인피니티 스크롤이나 페이지네이션 기능구현을 추가적으로 작성을 해보겠습니다. 읽어주셔서 감사합니다.
