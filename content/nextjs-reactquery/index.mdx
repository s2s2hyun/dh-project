---
title: 'Nextjs14 + React-query '
description: 'Nextjs14 + React-query  적용'
image: '../../public/blogs/logo/react-query-logo.png'
publishedAt: '2024-01-17'
updatedAt: '2024-01-17'
author: 'DH'
isPublished: true
tags:
  - Next.JS
---

NextJs 와 React-query를 같이 사용한다면 어떨까?

- React-query는 NextJs 에서 pre-fetching이 가능하다. 이로 인해 성능 향상에 도움을 준다.
  📌 pre-fetching 이란? 페이지가 렌더링 되기 전에 미리 데이터를 가져오는 것을 말한다.(데이터 캐싱 작업도 pre-fetching에 포함된다.)

- 데이터 요청 코드를 쉽게 관리가 가능하다.

- 동적 데이터 관리하는 비동기 로직을 쉽게 다룰 수 있다.

## 1. 설치

[react-query tanstack Link](https://tanstack.com/query/v4/docs/react/installation)

```
# npm
npm i @tanstack/react-query
# pnpm
pnpm add @tanstack/react-query
# yarn
yarn add @tanstack/react-query
```

### 2 Next.Js 에 적용

Next.js 13.4 버전 이상은 App Router 프로젝트로 만들수있으므로, 이번 설명은 App Router 기준으로 설명을 해보겠습니다.
여러 방법이 있는데, 저는 Provider 를 만들어 거기에 client 및 쿼리 생성 함수를 작성해 Layout에 적용하는 방법을 공유하겠습니다.

## 2.1 ReactQueryProvider 만들기

```
"use client";

import { QueryClientProvider, QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";

export default function ReactQueryProviders({
  children,
}: React.PropsWithChildren) {
  const [client] = useState(
    new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false, // 윈도우가 다시 포커스되었을때 데이터를 refetch
          refetchOnMount: false, // 데이터가 stale 상태이면 컴포넌트가 마운트될 때 refetch
          retry: 1, // API 요청 실패시 재시도 하는 옵션 (설정값 만큼 재시도)
        },
      },
    })
  );

  return (
    <QueryClientProvider client={client}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

```

1. 'use client' 를 추가.
   Next.Js App router 는 기본적으로 서버 컴포넌트지만, 리액트쿼리는 QueryClientProvider 를 비롯해 서버 컴포넌트에서 작동하지 않습니다.

2. useState로 new QueryClient 생성
   참조 동일성을 유지하고 React에서 예상대로 상태를 관리하는 데 도움돼 useState로 생성. 자세한 설명은 아래 추가적으로 하겠습니다.

3. defaultOptions 설정
   서버 비용을 줄이기 위해 refetch 설정을 false 로 두었습니다.

4. 만든 queryClient를 QueryClientProvider 컴포넌트의 client에 넣어줌

5. QueryClientProvider로 래핑을 하면 모든 하위 구성 요소가 React Query 환경에 액세스 할 수 있게 됩니다. 구성 요소 계층 구조를 통해 props를 깊이 전달할 필요 없이 다양한 구성 요소 간에 전역 상태를 관리하기 위함입니다.

6. ReactQueryDevtools은 선택이며, react-query 개발 도구라고 생각하시면 됩니다.

> 추가 : queryClient 설정에 useState를 활용했을까?

useState를 활용하는 것은 React Query의 QueryClientProvider 설정에서 특별한 경우의 선택이라 할 수 있다. useState를 적용하면 참조 동일성을 유지하며, 또한 React Query와 React가 예상하는 상태 관리를 조절하고, 컴포넌트 렌더링과 상태 업데이트를 조절하기 위함이다.
이에 대한 몇 가지 이유는 다음과 같다.

1. 초기 렌더링 중 설정: React Query는 초기 렌더링 동안에 QueryClient를 설정하고 사용하기 위한 상태를 필요로 한다.
   초기 렌더링 동안에만 실행되는 함수를 제공하면 Lazy 초기 상태(Lazy inital state)를
   활용해 초기 렌더링 동안에만 QueryClient를 생성하고, 이후에는 참조 동일성을 유지한다.
   이것은 초기 설정을 효율적으로 관리하는 방법 중 하나다.
2. 동적 설정 관리: QueryClientProvider의 설정을 동적으로 변경해야 할 때, useState 를 활용해 QueryClient를 상태로 관리하는 것이 유용하다. 동적으로 설정을 변경하려면 상태를 업데이트하고 그 변경을 QueryClientProvider 에 적용하면 된다.

3. 최적화 : React Query는 렌더링 성능과 데이터 캐싱에 대한 다양한 최적화를 제공하므로, 이러한 최적화를 활용해 웹 애플리케이션의 성능을 향상시킬 수 있다.

## 3. 루트 레이아웃에 적용하기

Next.Js App Router는 라우팅에 영향을 주는 파일 및 폴더가 있는데, 그 중 하나가 layout.tsx 이다.
간단하게 얘기해서 layout.tsx는 도메인 주소에 영향을 주는 page.tsx 파일 및 그 하위 디렉토리 파일들에게 UI 및 설정을 영향을 줄 수 있는 파일이다.
이전 Next.js Page Router 구조에서 \_app.tsx 와 비슷한 기능을 가진 파일이다.

<Image
  src="/blogs/nextjs-reactquery/nextjs-approuter.png"
  width="1000"
  height="600"
  alt="Image"
  sizes="100vw"
/>

```
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import ReactQueryProviders from "@/utils/react-query-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ReactQueryProviders>{children}</ReactQueryProviders>
      </body>
    </html>
  );
}

```

구현 완료입니다.

## 4. 추가적으로 Next.JS SSG , SSR 데이터를 React-query 로 가져와서 어떠한 이점이 있는지 추가적으로 업데이트 할 예정입니다.
